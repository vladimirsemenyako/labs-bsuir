% Лабораторная работа №2 по дисциплине "Логические основы интеллектуальных систем"
% Выполнена студентами группы 321701 БГУИР:
% - Семеняко Владимиром Дмитриевичем
% Вариант: 1, последнее изменение: 06.06.2025

% Данный файл является исходным кодом к программе, решающий следующую задачу:

% Два береги реки. На одном берегу есть 3 миссионера и 3 людоеда, требуется с помощью лодки
% вмещающей не более 2 человек, переправить всех на другой берег. Число присутствующих миссионеров
% на берегу и в лодке должно быть всегда не меньше числа людоедов.
% 1. Логические основы интеллектуальных систем. Практикум : учеб.- метод. %пособие / В. В. Голенков [и др.].
% – Минск : БГУИР, 2011. – 70 с. : ил. ISBN 978-985-488-487-5.
% 2. SWI Prolog [Электронный ресурс]. -- Режим доступа https://www.swi-%prolog.org/
% -----------------------------------------------------------------
% Предикат `legal`: Проверка безопасности состояния
% -----------------------------------------------------------------
% Проверяет, является ли текущее расположение людей на берегах "безопасным".
% Аргументы:
%   CL: Cannibals Left (Каннибалы на левом берегу)
%   ML: Missionaries Left (Миссионеры на левом берегу)
%   CR: Cannibals Right (Каннибалы на правом берегу)
%   MR: Missionaries Right (Миссионеры на правом берегу)
%
legal(CL, ML, CR, MR) :-
    % Убедимся, что количество людей не отрицательное.
    ML >= 0, CL >= 0, MR >= 0, CR >= 0,
    
    % Проверка для левого берега:
    % Либо миссионеров не меньше, чем каннибалов,
    % либо миссионеров на этом берегу вообще нет.
    (ML >= CL; ML = 0),
    
    % Аналогичная проверка для правого берега.
    (MR >= CR; MR = 0).

% -----------------------------------------------------------------
% Предикат `move`: Определение всех возможных ходов
% -----------------------------------------------------------------
% Описывает одно перемещение лодки из одного состояния в другое.
% Состояние представлено списком: [КЛ, МЛ, ПозицияЛодки, КР, МП].
% Позиция лодки: `lft` (слева) или `rgt` (справа).
%

% --- Перемещения с ЛЕВОГО на ПРАВЫЙ берег ---

% Переместить двух миссионеров влево -> вправо
move([CL, ML, lft, CR, MR], [CL, ML2, rgt, CR, MR2]) :-
    ML2 is ML - 2, % Уменьшаем число миссионеров слева
    MR2 is MR + 2, % Увеличиваем число миссионеров справа
    legal(CL, ML2, CR, MR2). % Проверяем, безопасен ли новый расклад

% Переместить двух каннибалов влево -> вправо
move([CL, ML, lft, CR, MR], [CL2, ML, rgt, CR2, MR]) :-
    CL2 is CL - 2,
    CR2 is CR + 2,
    legal(CL2, ML, CR2, MR).

% Переместить одного миссионера и одного каннибала влево -> вправо
move([CL, ML, lft, CR, MR], [CL2, ML2, rgt, CR2, MR2]) :-
    CL2 is CL - 1,
    ML2 is ML - 1,
    CR2 is CR + 1,
    MR2 is MR + 1,
    legal(CL2, ML2, CR2, MR2).

% Переместить одного миссионера влево -> вправо
move([CL, ML, lft, CR, MR], [CL, ML2, rgt, CR, MR2]) :-
    ML2 is ML - 1,
    MR2 is MR + 1,
    legal(CL, ML2, CR, MR2).

% Переместить одного каннибала влево -> вправо
move([CL, ML, lft, CR, MR], [CL2, ML, rgt, CR2, MR]) :-
    CL2 is CL - 1,
    CR2 is CR + 1,
    legal(CL2, ML, CR2, MR).


% --- Перемещения с ПРАВОГО на ЛЕВЫЙ берег (возвращение) ---

% Вернуть двух миссионеров вправо -> влево
move([CL, ML, rgt, CR, MR], [CL, ML2, lft, CR, MR2]) :-
    ML2 is ML + 2,
    MR2 is MR - 2,
    legal(CL, ML2, CR, MR2).

% Вернуть двух каннибалов вправо -> влево
move([CL, ML, rgt, CR, MR], [CL2, ML, lft, CR2, MR]) :-
    CL2 is CL + 2,
    CR2 is CR - 2,
    legal(CL2, ML, CR2, MR).

% Вернуть одного миссионера и одного каннибала вправо -> влево
move([CL, ML, rgt, CR, MR], [CL2, ML2, lft, CR2, MR2]) :-
    CL2 is CL + 1,
    ML2 is ML + 1,
    CR2 is CR - 1,
    MR2 is MR - 1,
    legal(CL2, ML2, CR2, MR2).

% Вернуть одного миссионера вправо -> влево
move([CL, ML, rgt, CR, MR], [CL, ML2, lft, CR, MR2]) :-
    ML2 is ML + 1,
    MR2 is MR - 1,
    legal(CL, ML2, CR, MR2).

% Вернуть одного каннибала вправо -> влево
move([CL, ML, rgt, CR, MR], [CL2, ML, lft, CR2, MR]) :-
    CL2 is CL + 1,
    CR2 is CR - 1,
    legal(CL2, ML, CR2, MR).


% -----------------------------------------------------------------
% Предикат `path`: Поиск пути решения (алгоритм поиска в глубину)
% -----------------------------------------------------------------

% Рекурсивное правило: как сделать один шаг в поиске.
% Аргументы:
%   Start:      Текущее состояние, из которого ищем путь.
%   End:        Целевое состояние, к которому стремимся.
%   Explored:   Список состояний, которые мы уже посетили (чтобы избежать циклов).
%   MovesList:  Список ходов, который строится для получения ответа.
%
path(Start, End, Explored, MovesList) :-
    % 1. Находим возможный следующий ход из текущего состояния (Start) в новое (NewState).
    move(Start, NewState),
    
    % 2. Убеждаемся, что мы еще не были в этом новом состоянии.
    not(member(NewState, Explored)),
    
    % 3. Рекурсивно продолжаем поиск пути из нового состояния (NewState).
    %    Добавляем NewState в список посещенных.
    %    Записываем сделанный ход (Start -> NewState) в список ходов.
    path(NewState, End, [NewState | Explored], [[NewState, Start] | MovesList]).

% Базовое правило: что делать, когда мы достигли цели.
% Срабатывает, когда текущее состояние (Start) совпадает с конечным (End).
path(End, End, _, MovesList) :-
    % Мы нашли решение! Вызываем предикат для печати результата.
    output(MovesList).


% -----------------------------------------------------------------
% Предикат `output`: Вывод найденного решения на экран
% -----------------------------------------------------------------

% Базовый случай рекурсии: если список ходов пуст, ничего не делать, кроме перехода на новую строку.
output([]) :- nl.

% Рекурсивное правило:
% Так как список ходов строился в обратном порядке (от конца к началу),
% мы используем рекурсию, чтобы напечатать его в правильном порядке.
output([[To, From] | Rest]) :-
    % 1. Сначала вызываем output для остальной части списка (хвоста).
    output(Rest),
    
    % 2. И только потом печатаем текущий ход.
    %    Это гарантирует, что первый ход будет напечатан последним.
    write(From), write(' -> '), write(To), nl.


% -----------------------------------------------------------------
% Предикат `find`: Удобная "обертка" для запуска поиска
% -----------------------------------------------------------------
% Просто вызывает `path`, задавая начальные параметры.
%   X: начальное состояние
%   Y: конечное состояние
%
find(X, Y) :-
    % Начинаем поиск пути из X в Y.
    % Начальный список посещенных состояний содержит только X.
    % Список ходов изначально пуст.
    path(X, Y, [X], []).
